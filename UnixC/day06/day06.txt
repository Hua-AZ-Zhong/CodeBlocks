1、复习
	底层文件IO
		open:O_RDONLY/O_WRONLY/O_RDWR,O_CREAT带权限,O_EXCL
		umask
		chmod/fchmod
		read
		write
		lseek
		close
		lstat/fstat/stat
		fxxx系列系统函数一般用于已经打开的文件描述符
	进程的常识:process  processor
		getpid,getppid,getgid,getuid,getcwd/*current working directory*/,gethostname,...
	
2、进程常识
	getpgid(pid)取得进程组id，setsid()自己成立一进程组
	atexit(清理工作)登记要在程序结束时做的清理工作。如果登记了多份清理工作，程序正常结束时按登记相反的顺序自动执行这些清理工作。每个“清理工作”是一个函数名，void func(void), 程序结束时系统自动调用，不传参数。
	on_exit(清理工作,清理时需要的参数)登记要在程序结束时做的清理工作。每个“清理工作”是一个函数名，void func(int,void*),其中int是程序结束时要返回的值（main里面return的值或者exit的参数值），void*是在on_exit中指定的“清理时需要的参数”。
	exit(int)结束当前进程，等同于在main函数中return一个整数。
	//_exit(int),_Exit(int)立即终止进程，清理工作都不做。
	进程结束时总是要：关闭已经打开的文件描述符，释放它所分配的动态内存，回收进程id。
	system(cmd)用来执行一个命令行，cmd表示命令行字符串。命令执行完毕之后返回。缺点：在命令行执行完毕之前，原来的进程处于等待状态什么也做不了。

3、多进程：多个任务同时工作
	fork()把当前进程克隆一份，克隆后的新旧进程只有进程id不同。新进程称为旧进程的子进程。两份进程都从克隆完成的那个地方继续运行！两份进程独立运行，谁先谁后没有规定。
	通过克隆前后的进程id比较是否相同可以确定进程是旧进程还是新进程。
	fork函数在执行到return3，4语句时已经完成克隆了，两份进程都会继续执行return语句，其中子进程return返回的是0，父进程return返回的是子进程的id（一定不是0）。如果返回-1意味着失败，这时候没有子进程。
	fork克隆是全部克隆，包括所有的函数、变量、缓冲区、打开的文件等整个进程空间中的一切。
		if(fork()==0){AB
			puts("1");B
		}//1个1
		if(fork()!=0){AC BD
			puts("2");AB
		}//2个2
		puts("3");//4个3

	每个进程结束时都应该由它的父进程去取得这个子进程的结束状态之后才应该彻底回收这个子进程占用的系统资源。因此每个进程都必须要有父进程。如果真正的父进程提前结束了，这时的子进程就成为了“孤儿进程”，由init进程负责领养它。init是系统中的孤儿院。
	如果子进程先结束，就成为僵尸进程，等待父进程处理它之后彻底回收进程资源。
	父进程结束就会出现命令提示符，终端输入就交由shell来处理了。
	#include <sys/wait.h>
	pid_t wait(int* s)等待任意一个子进程结束，取得子进程的结束信息保存在s所指的变量中，返回那个子进程的id。如果没有子进程，wait失败，返回-1。s如果为空就丢弃结束信息。wait之后的子进程资源就会自动彻底回收。
	pid_t waitpid(childid,int* s,0或者WNOHANG)取得指定子进程的结束信息保存在s所指的变量中，返回那个子进程id。如果第三个参数是0就等到那个子进程结束为止，如果第三个参数是WNOHANG则不等待。如果s为空就丢弃结束信息。childid如果用-1表示任意子进程。如果子进程没有结束而且第三个参数是WNOHANG返回0。
	子进程结束后，结束信息里有多个数据，用WIFEXITED(结束信息)可以检测子进程是否是正常结束的，如果是正常结束的，可以用WEXITSTATUS(结束信息)取得结束时的返回值。如果不是正常结束那就是因为收到信号结束的，可以用WIFSIGNALED(结束信息)来判断是否是被信号终止的以及用WTERMSIG(结束信息)来取得是被哪个信号终止的。

作业：写一个程序，开启3个子进程，每个子进程每秒打印一个字符（第一个子进程打印a，第二个打印b，第三个打印c），然后父进程结束。再写一个程序，用来终止前面的3个子进程。
