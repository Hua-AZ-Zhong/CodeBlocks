1、大复习
C++:
	面向对象
		封装
			定义类：抽象，内部类型
			创建对象：构造函数（默认，拷贝，匿名对象，explicit，初始化列表），析构函数（释放额外资源），运算符重载（=，成员/非成员形式a+b:a.operator+(b)/operator+(a,b)，后++--int哑元，<<,>>），this，静态成员（函数，变量）
		继承
			单继承，public继承，protected访问限制对子类网开一面，构造（顺序，参数在子类初始化列表里传递），析构顺序，子类重新定义成员时会隐藏来自父类的同名成员，“is-a”
			多重继承：多个父类，构造顺序由继承顺序决定，参数由初始化列表传递，父类间同名冲突用父类名双冒号区分，析构顺序相反
			虚继承：多个父类在继承更上级父类时用virtual关键字，共同的父类在子类中会合并，虚基类的构造参数由子类构造的初始化列表传递
		多态
			用父类对象身份（父类指针或者引用）来访问虚函数，实际执行的是实际对象所属子类中的虚函数，（1）继承关系（2）调用的是虚函数（3）使用指针或者引用
			虚函数表：每个有虚函数的类都有一个（在多重继承中可能有多个），每个有虚函数的对象都有指针指向虚函数表，typeid，dynamic_cast<子类*>(父类或子类对象)
			虚函数：父类定义后子类中自动有这个虚函数，子类可以自己覆盖（同名同参数表同返回类型），虚析构函数，纯虚函数，抽象类（不能直接用于创建对象）
	模板
		程序样板，是对函数和类的抽象（允许有未定类型，编译时实例化），函数模板一般可以自动实例化（编译器通过实参去推测形参类型），类模板必须人为实例化。
		自定义模板：每个模板必须有自己的模板头，模板形参可以是类型也可以是非类型（一般是整数），类模板形参可以有默认值。模板可以全特化、偏特化、部分特化。尽量不要把声明和定义分开。
		STL：一般用<来比较大小
			容器：
				关联式：set/multiset/map/multimap
				序列式：vector/deque/list
			迭代器:iterator/const_iterator/reverse_iterator/const_reverse_iterator，++,*,->,==,!=,=,--，模仿指针
			适配器:stack/queue/priority_queue
			（分配器）
			算法：函数模板，一般前两个参数是一个区间
			函数对象：支持()运算符的类的对象，less<int> x; greater<int> y;
			
	IO：
		控制台：格式化（人方字符串机方二进制）和非格式化（全当二进制），格式控制，错误检测和处理，IO类体系
		文件：构造/open，析构/close，read/write/seekp/seekg/gcount，控制台那一套。
		字符串：构造指定字符串对象，之后就使用控制台那一套一样的方式把字符串对象当作控制台

	异常：集中进行错误处理
		try{throw xxx;}catch(...){}
		exception类what()
		异常声明

	数据结构和算法
		链表：链接式存储的线性表，处理链表一般是“从头开始，顺藤摸瓜，到尾为止”，改动链表一定要用链表中的原始指针。
		用数组和链表实现栈和队列
		二叉查找树：自动排序，方便查找。一个操作一般分两个函数（一个与节点无关的公开函数对外供用户调用，一个与根节点相关的私有函数用于递归处理各个子树），递归处理模式：如果是空树就直接处理，否则分成左右子树和根节点，单独处理根节点，递归处理左右子树。
		常见排序算法：冒泡、插入、选择、快速、（希尔、归并）……

UC:
	静态库：把函数和相关的全局变量写在若干个.c文件里，编译成.o文件之后用ar命令打包成libxxx.a文件。使用静态库时，直接把自己的程序用gcc跟libxxx.a文件一起连接就可以了，也可以用选项-lxxx -L.来连接。库中的函数和变量会直接存放到产生的可执行文件中。运行时就不再需要库文件了。
	动态库：把函数和相关的全局变量写在若干个.c文件里，编译连接时用选项-shared产生libxxx.so文件。使用动态库时，把自己的程序跟动态库用选项-lxxx -L.连接起来，但库中的函数和变量并没有加入到可执行文件中，因此在运行时还需要通过环境变量LD_LIBRARY_PATH去找动态库文件libxxx.so。
	头文件：函数和变量的声明
	动态加载：dlopen/dlerror/dlsym/dlclose
	环境变量：getenv/setenv/putenv
	内存分配：建议用c的，sbrk/brk，mmap(0,len,,,0,0)
	文件系统：
		通用的：rename/remove/symlink/lstat/access/chmod
		目录的：opendir/readdir/closedir,mkdir/rmdir/chdir/getcwd
	错误处理：errno,strerror,perror,"%m"
	时间系统：time/localtime/gmtime/mktime/strftime

2、讲解假期作业
实现ls -l的功能：

3、低级文件IO
	宏观的：unlink(文件路径)删除一个文件, readlink(文件路径,字符数组名,数组大小)读取符号链接文件本身的内容（也就是目标路径）到字符数组中（不会自动加\0），返回字符数，-1表示失败。
	文件内容操作
	//creat
	open(文件路径，打开方式[,权限])打开一个文件，返回文件描述符为一个尽可能小的非负整数，失败返回-1。
	打开方式：O_RDONLY=0,O_WRONLY=1,O_RDWR=2三选一,O_APPEND追加，O_CREAT如果文件不存在就新建（有这个打开方式时就需要指定open的第三个参数）,O_TRUNC以写方式打开已经存在的文件时清空全部数据截断成0长度，O_EXCL跟O_CREAT一起表示必须新建文件（如果文件已经存在则打开失败），O_NONBLOCK不阻塞
	read(文件描述符,读来往哪里放,最多读多少字节)从一个打开的文件中顺序读取数据，返回读取到的字节数，失败返回-1，返回0表示读取到文件末尾了。
	write(文件描述符,把哪里的数据存到文件中，存多少字节）把内存中的数据顺序保存到一个打开的文件中，返回保存的字节数。
	close(文件描述符)关闭一个打开的文件，清空文件缓冲区。
	//sync,fsync,fdatasync
	lseek(文件描述符,偏移量,参考点)指定一个打开的文件下一次读写的开始位置，返回这个位置从文件头开始的偏移量。参考点跟标准C一样：SEEK_SET/SEEK_CUR/SEEK_END。（允许指定超过文件尾的位置，超越的部分成为空洞）。
	ftruncate(文件描述符,大小）把文件截成指定大小。
	truncate(文件路径，大小)把文件截成指定大小。
	//dup,dup2
	特殊文件描述符：0标准输入设备文件，1标准输出设备文件，2标准错误设备文件
	特殊文件：/dev/tty当前终端,/dev/pts/n编号为n的虚拟终端，/dev/null空设备文件（无底洞），//  /dev/zero
	fcntl(文件描述符,命令,struct flock*)功能很多，但一般用来给文件加锁解锁
	//ioctl调用驱动程序接口，不同的驱动使用的参数及其含义各不相同。
	mmap


